---
title: "aggregate visualization data"
output: html_document
---



Package loading...
```{r packages}
library(ggplot2)
library(dplyr)
library(countrycode)
```


Setting local directory and suppressing scientific notation of numbers..
```{r set_directory, echo=FALSE}
# make sure local path is same as this file
getwd()
#list.files()
#setwd(paste0(getwd(), "/data"))
# suppress scientific notation, just a hack i guess...
options(scipen=999)
```





Let's import the mobile data set and add country code so that we can merge the GNI data by a common value later.
```{r mobile_import}
mobile <- read.csv("mobile-parameters-q2-2015-updated.csv",
                   header = TRUE, sep = ",", strip.white = TRUE)

mobile$Code <- countrycode(mobile$Country, "country.name", "wb")
```


After combining data sets later on in this script, we found out that several country's currency codes are wrong...
```{r mobile_fix_currency_codes}
mobile$Tarrif.Currecy <- as.character(mobile$Tarrif.Currecy)

index <- mobile$Country == "Mali"
mobile$Tarrif.Currecy[index] <- "XOF"

index <- mobile$Country == "Togo"
mobile$Tarrif.Currecy[index] <- "XOF"

index <- mobile$Country == "Benin"
mobile$Tarrif.Currecy[index] <- "XOF"

index <- mobile$Country == "Burkina Faso"
mobile$Tarrif.Currecy[index] <- "XOF"

index <- mobile$Country == "Timor-Leste"
mobile$Tarrif.Currecy[index] <- "USD"

# Below changes done manually while inspecting currency codes for validity...

#index <- mobile$Country == "Aruba"
#mobile$Tarrif.Currecy[index] <- "AWG"
#index <- mobile$Country == "Barbados"
#mobile$Tarrif.Currecy[index] <- "BBD"
#index <- mobile$Country == "Ghana"
#mobile$Tarrif.Currecy[index] <- "GHS"
#index <- mobile$Country == "New Caledonia"
#mobile$Tarrif.Currecy[index] <- "XPF"
#index <- mobile$Country == "Tanzania"
#mobile$Tarrif.Currecy[index] <- "TZS"
#index <- mobile$Country == "Palestinian Territory"
#mobile$Tarrif.Currecy[index] <- "ILS"
```


Let's check if any countries have more than one currency code...
```{r mobile_check_currency}
check <- mobile %>% distinct(Tarrif.Currecy) %>% group_by(Country) %>%
  summarise(count = n()) %>% filter(count > 1)

check <- as.vector(check$Country)
check

redos <- mobile %>% filter(Country %in% check) %>%
  distinct(Tarrif.Currecy) %>% select(Tarrif.Currecy)

redos <- as.vector(unlist(redos))
redos
```


We can recode those errors to keep that data...
```{r mobile_recode_redundant}
# Afghanistan done manually while validating currency codes manually

#index <- mobile$Tarrif.Currecy == "AFS"
#mobile$Tarrif.Currecy[index] <- "AFN"

index <- mobile$Tarrif.Currecy == "CKZ"
mobile$Tarrif.Currecy[index] <- "CZK"
```


Fill in missing 'Cost' data with 'Monthly.cost' data and remove any NAs. Also, let's keep only the relevant features...
```{r mobile_combine_costs}
str(mobile)
# the 'Cost' feature needs to be numeric first.
# as numeric from factor would assign a number corresponding to the level
# of the factor. we need as character before numeric to get the value.
mobile$Cost <- as.numeric(as.character(mobile$Cost))

nas <- is.na(mobile$Cost)
mobile[nas, ]$Cost <- mobile[nas, ]$Monthly.cost

# remove rows without any cost data
mobile <- subset(mobile, !is.na(Cost))

# double check voice/sms types before keeping
table(mobile$Voice...SMS.Included.)

mobile <- mobile %>% select(Country, Code, Usage.allowance, Allowance.units,
                            Validity..days., Cost, Voice...SMS.Included.,
                            Tarrif.Currecy)
```





Now we can add the relevant exchange rate and GNI data...
```{r gni_xrates_import}
gni_usd <- read.csv("world-gni-historic.csv", header = TRUE,
                           sep = ",")
xrates_usd <- read.csv("xrates-2015.csv", header = TRUE, sep = ",")
```


Any missing 2014 GNI data is replaced by either 2013 or in a few rare cases 2012...
```{r gni_fill_missing}
nas <- is.na(gni_usd$X2014)
gni_usd[nas, ]$X2014 <- gni_usd[nas, ]$X2013

nas <- is.na(gni_usd$X2014)
gni_usd[nas, ]$X2014 <- gni_usd[nas, ]$X2012

# still missing a good chunk of data
nas <- is.na(gni_usd$X2014)
sum(nas)
# for these countries
as.vector(unlist(gni_usd[nas, ]$Country.Code))

gni_usd <- gni_usd %>% select(Country.Code, X2014)
```





Now we can merge the exchange rate and GNI data to the mobile data...
```{r combine_data_sets}
combine <- merge(mobile, xrates_usd, by.x = "Tarrif.Currecy",
                  by.y = "Currency_Code", all.x = TRUE)

combine <- merge(combine, gni_usd, by.x = "Code",
                  by.y = "Country.Code", all.x = TRUE)

# see if we have xrates for all countries in the merged data set
check <- combine %>% filter(is.na(USDxrate)) %>%
  distinct(Tarrif.Currecy) %>% select(Code, Tarrif.Currecy, Country)
# all countries have xrates!
```


The names are not precise and kind of inconvenient...
```{r combine_rename_features}
names(combine)

names(combine) <- c("country.code", "currency.code", "country.name",
                    "data.amount", "data.unit", "expiry",
                    "cost.local", "voice.sms","usdxrate", "gni")
```


Now that we have country name together with GNI data we can add a few GNIs manually from the web...
```{r combine_manual_gni}
nas <- is.na(combine$gni)
# missing data
missing <- combine[nas, ]
# and the counts
counts <- missing %>% group_by(country.name) %>% summarise(n())

index <- combine$country.name == "Aruba"
combine$gni[index] <- 23649
index <- combine$country.name == "Andorra" #2008!
combine$gni[index] <- 43110
index <- combine$country.name == "Angola"
combine$gni[index] <- 6670
index <- combine$country.name == "Anguilla"
combine$gni[index] <- 19732
index <- combine$country.name == "Cayman Islands"
combine$gni[index] <- 53271
index <- combine$country.name == "Congo Democratic Republic"
combine$gni[index] <- 680
index <- combine$country.name == "Cook Islands"
combine$gni[index] <- 15003
index <- combine$country.name == "Cuba"
combine$gni[index] <- 18520
index <- combine$country.name == "Curacao"
combine$gni[index] <- 20167
index <- combine$country.name == "Djibouti"
combine$gni[index] <- 1936
index <- combine$country.name == "French Polynesia"
combine$gni[index] <- 20099
index <- combine$country.name == "Greenland"
combine$gni[index] <- 42408
index <- combine$country.name == "Monaco"
combine$gni[index] <- 187650
index <- combine$country.name == "New Caledonia"
combine$gni[index] <- 39392
index <- combine$country.name == "New Zealand"
combine$gni[index] <- 30750
index <- combine$country.name == "Palestinian Territory"
combine$gni[index] <- 4900
index <- combine$country.name == "Romania"
combine$gni[index] <- 18060
index <- combine$country.name == "Somalia"
combine$gni[index] <- 125
index <- combine$country.name == "Syria"
combine$gni[index] <- 1784
index <- combine$country.name == "Taiwan"
combine$gni[index] <- 22598
index <- combine$country.name == "Timor-Leste"
combine$gni[index] <- 2494

# no gni data for these countries
nas <- is.na(combine$gni)
# missing data
missing <- combine[nas, ]
# the counts
counts <- missing %>% group_by(country.name) %>% summarise(n())
# missing country names only
missing <- unlist(as.vector(counts$country.name))
missing
```


Let's remove those countries with no GNI info
```{r remove_no_gni}
combine <- combine %>% filter(!(country.name %in% missing))
```


Create a USD cost for each mobile plan and a monthly GNI.
```{r combine_add_usdcost_gnimonth}
combine <- combine %>% mutate(cost.usd = cost.local/usdxrate) %>%
  mutate(gni.month = gni/12)
```


Let's convert MB to GB for easier aggregation.
```{r combine_mb_gb}
# logical vector of rows with "MB" as data unit
#mb <- combine$data.unit == "MB" & (combine$expiry == 1 | combine$expiry == 7 | combine$expiry == 30)
mb <- combine$data.unit == "MB"

# CHECK SELECTION BEFORE
#combine[mb, ]

# slice df by "GB" and "1" rows and assign new units and amounts
combine[mb, ]$data.amount <- (combine[mb, ]$data.amount / 1000)
combine[mb, ]$data.unit <- "GB"

# CHECK SELECTION AFTER
#combine[mb, ]

# what kind of types and counts do we have left here?
table(combine$data.unit)

# some kilobytes, must be bad data
bad <- subset(combine, data.unit == "KB")
# only one observation in Iraq but definitely bad data
# no way 1GB should cost 5k USD
# it should be "MB" let's treat it as so
kb <- combine$data.unit == "KB"
combine[kb, ]$data.amount <- (combine[kb, ]$data.amount / 1000)
combine[kb, ]$data.unit <- "GB"
#combine <- subset(combine, data.unit != "KB")
```


Let's see how many observations have voice/sms included and get counts of different expiry types. 
```{r explore_voicesms_expiry_types}
check <- subset(combine, voice.sms == "Yes")
nrow(check)

table(combine$expiry)
# let's order these with dplyr instead

str(combine)
# first convert to numeric
combine$expiry <- as.numeric(as.character(combine$expiry))
# counts of different durations of plans
plan.counts <- combine %>% group_by(expiry) %>% summarise(count = n()) %>%
  arrange(expiry)
# there are some numbers below 1 but looking at the original data they seem
# to be coding errors and should be 1.
```


The price per GB is inflated with voice.sms plans so let's keep it simple and exclude these.  Also expiry tends to affect this too, let's keep monthly-ish plans only (28-31 days).
```{r filter_expiry_voice_plans}
combine <- subset(combine, voice.sms == "No" & (expiry <= 31 & expiry >= 28))
```





Now let's group by country to get total data amount and total cost. From here we can get an average cost in USD per GB...
```{r final_df_costpergb}
# need to groupby 'gni.month' and 'country.code' here or it gets removed in the chain
final_df <- combine %>%
  group_by(country.code, country.name, gni.month) %>%
  summarise(total.amount = sum(data.amount),
            total.cost = sum(cost.usd)) %>%
  mutate(cost.usd.per.gb = total.cost/total.amount)
```


We have average cost in USD per GB but this doesn't quite paint an accurate picture mobile data accessibility.  For this we can compare the typical monthly usage (2GB) bill divided by the montly GNI per capita.  The 2GB approximate average monthly usage comes from a few online sources.  In the US, the average person consumes about 2GB of mobile data (although this doesn't include mobile wifi as in free hotspots at starbucks which is apparently close to an additional 8GB per month). This relative measure of mobile data accessibility will really in brining to life the choropleth map.
```{r final_df_percent_income}
final_df <- final_df %>%
  mutate(percent.income = 100*2*cost.usd.per.gb/gni.month) %>%
  select(-total.amount, -total.cost)
```


Let's make sure our relative measure domain is reasonable for a choropleth map...
```{r final_df_domain_check}
summary(final_df)
ggplot(aes(x = cost.usd.per.gb), data = final_df) +
  geom_histogram()
# we have some major outliers, let's see all high values...
check <- subset(final_df, cost.usd.per.gb > 30)
# let's also look at the smaller values
check <- subset(final_df, cost.usd.per.gb < 2)
# manual inspection for some bad values in each country was done on the
# original csv after this
```


Let's cut cost per GB and cost as percent of income into buckets for better visualization in d3...
```{r final_df_domain_buckets}
final_df$cost.usd.per.gb.bucket = cut(final_df$cost.usd.per.gb,
                                      c(0, 2, 5, 10, 20, 30, 50, +Inf),
                                      labels = c('0-2', '2-5', '5-10', '10-20',
                                                 '20-30', '30-50', '50-'))
final_df$cost.usd.per.gb.bucket <- as.character(final_df$cost.usd.per.gb.bucket)

final_df$percent.income.bucket = cut(final_df$percent.income,
                                      c(0, 1, 3, 5, 10, 20, 40, +Inf),
                                     labels = c('0-1', '1-3', '3-5', '5-10',
                                                 '10-20', '20-40', '40-'))
final_df$percent.income.bucket <- as.character(final_df$percent.income.bucket)
```




Write data to csv for d3 visualization...
```{r final_df_write_csv}
ordering <- c("country.code", "country.name", "gni.month", "cost.usd.per.gb",
              "percent.income", "cost.usd.per.gb.bucket",
              "percent.income.bucket")

final_df <- final_df[, ordering]

# round numbers
final_df$gni.month <- round(final_df$gni.month, 2)
final_df$cost.usd.per.gb <- round(final_df$cost.usd.per.gb, 2)
final_df$percent.income <- round(final_df$percent.income, 2)

write.csv(final_df, file = "mobile-world-data.csv", row.names = FALSE)
```
